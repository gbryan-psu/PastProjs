The overall design and implementation of this project was arguably the hardest aspect. We shifted and changed overall designs consistently in order to more easily implement the scheduler system. We started with implementing a node struct that held the information of the threads. Linked lists were then implemented for Running, Ready, and Blocked using the node structure that we had made. We shortly realised that using a single node design for Running was going to be easier as we only had to track one node’s information. Once we had set up all the functions for pushing and popping data from the linked lists we moved on to our first attempt at implementing FCFS in the scheduler. This led to a major list of problems, because of a large amount of data loss and pointer errors we genuinely could not tell if our organization and conditionals for FCFS were even right. While attempting to debug our problems with the linked list implementation, we designed and implemented a base for the P() and V() functions even though we were no where close to using them yet in the program. We reached a point at which we thought that we had resolved all pointer errors and that we were just doing something wrong with the actual scheduler implementation. This is when we realized the need for pthread functions and mutex lock. The reason for our multiple lock functions was to easily track data and lock calls especially during debugging. After implementing the pthread functions and a mutex lock we started to see some small success in FCFS. After debugging became ultimately futile we decided that switching to an array design might be more promising. We first set up arrays of nodes for the Ready and Blocked queues, ultimately sticking with a single node design for the Running thread. We set up new functions to push and pop the data from these arrays as well as setup sorting algorithms that would sort the arrays based on what scheduling type is being used. This is where we first saw some actual success with FCFS scheduling. Through some debugging and conditional changes we were able to consistently receive good output for FCFS on input_0 and input_1 (screenshots of our output located at bottom of report). We moved on to SRTF before implementing FCFS to be full-proof. We were able to get some minor success for SRTF on input_0 (screenshot at bottom of report), but we never got a fully correct output for SRTF. At this point, we were coming down to the last day to work on the project so we moved on to implementing P() and V() with the array format. We set these functions up including the pthread functions for wait/signal, but we did not have enough time to debug and fully implement them.
Our challenges first started with an understanding of globalTime and currentTime. At first we were manually incrementing globalTime which led us to errors with output. This error in understanding was not remedied until very far into the project when we realized that we could use the input of currentTime to manipulate globalTime. The most frequent challenge that we were faced with was our own assumptions on the project. Throughout we assumed what we were supposed to be doing with the implementation just to realize that our design would not work or was filled with errors. This challenge was constantly recurring,  and we had to hurdle this challenge multiple times. The challenge that negatively affected us the most was using our linked list design for such a long period of working on the project. Our implementation of a linked list was ultimately a failure as we could not get FCFS to correctly work. In order to overcome this, we switched our entire design to arrays. This array design did end up being a successful design for the base cases of scheduling in this program. One of the last challenges was understanding, using, and manipulating the pthread functions and the mutex lock. We left the implementation of these out for too long as we wanted to get a base program made that worked to then build off of that. Once these functions were implemented, we started to get some forms of success with FCFS.
Going into this project we wanted to fairly partition throughout the entire time of working. We started by meeting throughout the week to work together and get the base design of our project implemented. This worked out well as we were both on the same page for everything that was going on within the program. We switched to working alone and updating each other on a daily basis in order to more easily debug and try new implementations out. When either of us would have a major discovery or a working portion of code, we would merge our files and make sure we had the same code. Staying up to date with each others code helped us work through debugging much better as well as improved our ability to quickly try out implementations and determine if they were reasonable for use or not. Through this first project we have been able to work on our collaboration and improve our group work for the next projects. Yonathan contributing the majority of the code currently in our program as he was consistently able to make breakthroughs. He implemented the new array format, the pthread functions, and the mutex locks. Gabien worked on the implementation of the semaphores, P() and V() calls, and some minor functions. Yonathan was able to successfully get FCFS working with input_0 and input_1, while Gabien had some minor success in the implementation of SRTF.
The specifics that we wanted to share about our project mainly deal with the implementation of the scheduler. Our FCFS utilizes sorting of the blocked queue based on when the thread first came through the scheduler and its currentTime. Through this sorting and conditional statements we successfully had output for FCFS. Our SRTF utilizes similar sorting to FCFS. We sort the ready queue based off the remaining time that was entered when the thread first was passed into the scheduler. Our PBS utilized mainly comparisons in order to find the thread with highest priority. Based on the outputs and inputs given, we designed our PBS that 1 was the highest priority. PBS also utilizes SRTF for when priorities are the same. Our MLFQ utilizes a counter to keep track of the 5 levels of the Ready Queue. Using this counter we can keep track of the aging for each thread. Our PBS and MLFQ were not tested and do not output correct results. 
Some side notes we would like to make on this project stem mainly from the amount of challenges we had while working. We feel that the project description and given materials gave us a good direction to head in for this project, but this information was not enough for us to guide ourselves accurately through the project. The amount of challenges we had based solely on design and use of certain functions such as the mutex and pthread could have been either more easily resolved or not a problem at all. Including more directions to specifics of implementation and design would have been greatly appreciated such as example manipulation of linked lists in a program design closely related to scheduling.